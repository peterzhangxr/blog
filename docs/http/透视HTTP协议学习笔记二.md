# 透视HTTP协议学习笔记二
## 05 | 常说的“四层”和“七层”到底是什么？“五层”“六层”哪去了？
### TCP/IP网络分层模型
* 第一层叫“链接层”（link layer），负责在以太网、WiFi 这样的底层网络上发送原始数据包，工作在网卡这个层次，使用 MAC 地址来标记网络上的设备，所以有时候也叫 MAC 层。
* 第二层叫“网际层”或者“网络互连层”（internet layer），IP 协议就处在这一层。因为 IP 协议定义了“IP 地址”的概念，所以就可以在“链接层”的基础上，用 IP 地址取代 MAC 地址，把许许多多的局域网、广域网连接成一个虚拟的巨大网络，在这个网络里找设备时只要把 IP 地址再“翻译”成 MAC 地址就可以了。
* 第三层叫“传输层”（transport layer），这个层次协议的职责是保证数据在 IP 地址标记的两点之间“可靠”地传输，是 TCP 协议工作的层次，另外还有它的一个“小伙伴”UDP。

TCP 是一个有状态的协议，需要先与对方建立连接然后才能发送数据，而且保证数据不丢失不重复。而 UDP 则比较简单，它无状态，不用事先建立连接就可以任意发送数据，但不保证数据一定会发到对方。两个协议的另一个重要区别在于数据的形式。TCP 的数据是连续的“字节流”，有先后顺序，而 UDP 则是分散的小数据包，是顺序发，乱序收。

### OSI 网络分层模型
* 第一层：物理层，网络的物理形式，例如电缆、光纤、网卡、集线器等等；
* 第二层：数据链路层，它基本相当于 TCP/IP 的链接层；
* 第三层：网络层，相当于 TCP/IP 里的网际层；
* 第四层：传输层，相当于 TCP/IP 里的传输层；
* 第五层：会话层，维护网络中的连接状态，即保持会话和同步；
* 第六层：表示层，把数据转换为合适、可理解的语法和语义；
* 第七层：应用层，面向具体的应用传输数据。

> 所谓的“四层负载均衡”就是指工作在传输层上，基于 TCP/IP 协议的特性，例如 IP 地址、端口号等实现对后端服务器的负载均衡。

> 所谓的“七层负载均衡”就是指工作在应用层上，看到的是 HTTP 协议，解析 HTTP 报文里的 URI、主机名、资源类型等数据，再用适当的策略转发给后端服务器。

**有一个辨别四层和七层比较好的（但不是绝对的）小窍门，“两个凡是”：凡是由操作系统负责处理的就是四层或四层以下，否则，凡是需要由应用程序（也就是你自己写代码）负责处理的就是七层。**

* **二层转发：**设备工作在链路层，帧在经过交换机设备时，检查帧的头部信息，拿到目标mac地址，进行本地转发和广播
* **三层路由：**设备工作在ip层，报文经过有路由功能的设备时，设备分析报文中的头部信息，拿到ip地址，根据网段范围，进行本地转发或选择下一个网关
* DNS和CDN都是工作在应用层

## 08 | 键入网址再按下回车，后面究竟发生了什么？

## 09 | HTTP报文是什么样子的？
HTTP协议的核心就是它传输的报文内容。

拿 TCP 报文来举例，它在实际要传输的数据之前附加了一个 20 字节的头部数据，存储 TCP 协议必须的额外信息，例如发送方的端口号、接收方的端口号、包序号、标志位等等。

它是一个“纯文本”的协议，所以头数据都是 ASCII 码的文本， ASCII 码, 一个字节表示一个字母, 所有 HTTP 报文会比较大 而那些二进制协议, 可以利用一个字节的 8 个比特表示更多信息, 这些信息通常是协议规定, 所以需要对应程序进行解析

HTTP 协议的请求报文和响应报文的结构基本相同，由三大部分组成：
* 起始行（start line）：描述请求或响应的基本信息；
* 头部字段集合（header）：使用 key-value 形式更详细地说明报文；
* 消息正文（entity）：实际传输的数据，它不一定是纯文本，可以是图片、视频等二进制数据。

HTTP 协议规定报文必须有 header，但可以没有 body，而且在 header 之后必须要有一个“空行”，也就是“CRLF”，十六进制的“0D0A”。

实体字段里要说的一个是 Content-Length，它表示报文里 body 的长度，也就是请求头或响应头空行后面数据的长度。服务器看到这个字段，就知道了后续有多少数据，可以直接接收。如果没有这个字段，那么 body 就是不定长的，需要使用 chunked 方式分段传输。

Content-Length 和 Transfer-Encoding:chuncked 是互斥的

* 在Nginx里，默认的请求头大小不超过8k，但可以用指令“large_client_header_buffers”修改

## 10 | 应该如何理解请求方法？
目前 HTTP/1.1 规定了八种方法，单词都必须是大写的形式，
* GET：获取资源，可以理解为读取或者下载数据；
* HEAD：获取资源的元信息；
* POST：向资源提交数据，相当于写入或上传数据；
* PUT：类似 POST；
* DELETE：删除资源；
* CONNECT：建立特殊的连接隧道；
* OPTIONS：列出可对资源实行的方法；
* TRACE：追踪请求 - 响应的传输路径。

### 安全与幂等
在 HTTP 协议里，所谓的“安全”是指请求方法不会“破坏”服务器上的资源，即不会对服务器上的资源造成实质的修改。

所谓的“幂等”实际上是一个数学用语，被借用到了 HTTP 协议里，意思是多次执行相同的操作，结果也都是相同的，即多次“幂”后结果“相等”。

按照http协议，空白行就是为了分隔header和body，因为http是纯文本的协议。

## 11 | 你能写出正确的网址吗？

## 12 | 响应状态码该怎么用？

“301 Moved Permanently”俗称“永久重定向”，含义是此次请求的资源已经不存在了，需要改用新的 URI 再次访问。

与它类似的是“302 Found”，曾经的描述短语是“Moved Temporarily”，俗称“临时重定向”，意思是请求的资源还在，但需要暂时用另一个 URI 来访问。

301 和 302 都会在响应头里使用字段 Location 指明后续要跳转的 URI，最终的效果很相似，浏览器都会重定向到新的 URI。两者的根本区别在于语义，一个是“永久”，一个是“临时”，所以在场景、用法上差距很大。

比如，你的网站升级到了 HTTPS，原来的 HTTP 不打算用了，这就是“永久”的，所以要配置 301 跳转，把所有的 HTTP 流量都切换到 HTTPS。

再比如，今天夜里网站后台要系统维护，服务暂时不可用，这就属于“临时”的，可以配置成 302 跳转，把流量临时切换到一个静态通知页面，浏览器看到这个 302 就知道这只是暂时的情况，不会做缓存优化，第二天还会访问原来的地址。

“304 Not Modified” 是一个比较有意思的状态码，它用于 If-Modified-Since 等条件请求，表示资源未修改，用于缓存控制。它不具有通常的跳转含义，但可以理解成“重定向已到缓存的文件”（即“缓存重定向”）。

* 405 Method Not Allowed：不允许使用某些方法操作资源，例如不允许 POST 只能 GET；
* 406 Not Acceptable：资源无法满足客户端请求的条件，例如请求中文但只有英文；
* 408 Request Timeout：请求超时，服务器等待了过长的时间；
* 409 Conflict：多个请求发生了冲突，可以理解为多线程并发时的竞态；
* 413 Request Entity Too Large：请求报文里的 body 太大；
* 414 Request-URI Too Long：请求行里的 URI 太大；
* 429 Too Many Requests：客户端发送了太多的请求，通常是由于服务器的限连策略；
* 431 Request Header Fields Too Large：请求头某个字段或总体太大；


“501 Not Implemented”表示客户端请求的功能还不支持，这个错误码比 500 要“温和”一些，和“即将开业，敬请期待”的意思差不多，不过具体什么时候“开业”就不好说了。


“503 Service Unavailable”表示服务器当前很忙，暂时无法响应服务，我们上网时有时候遇到的“网络服务正忙，请稍后重试”的提示信息就是状态码 503。

503 是一个“临时”的状态，很可能过几秒钟后服务器就不那么忙了，可以继续提供服务，所以 503 响应报文里通常还会有一个“Retry-After”字段，指示客户端可以在多久以后再次尝试发送请求。

## 13 | HTTP有哪些特点？

### HTTP 协议是一个“灵活可扩展”的传输协议。
### HTTP 协议是一个“可靠”的传输协议。
### HTTP 协议是一个应用层的协议。
### HTTP 协议使用的是请求 - 应答通信模式。
### HTTP 协议是无状态的。

